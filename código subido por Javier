#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_LINE_SIZE 1024


struct node {
    char nombre[50];
    int danger;
    float attack;
    struct node *next;
};


void hash(struct node *lista_5, struct node *lista_4, struct node *lista_3, struct node *lista_2, struct node *lista_1,void imprimir_lista()){
    printf("%i---->", 5);
    imprimir_lista(lista_5);
    printf("\n");
    printf("\n");
    printf("%i---->", 4);
    imprimir_lista(lista_4);
    printf("\n");
    printf("\n");
    printf("%i---->", 3);
    imprimir_lista(lista_3);
    printf("\n");
    printf("\n");
    printf("%i---->", 2);
    imprimir_lista(lista_2);
    printf("\n");
    printf("\n");
    printf("%i---->", 1);
    imprimir_lista(lista_1);
}

void insertar_elemento(struct node **ref_lista, char* nombre,int danger, float attack)
{
    if (*ref_lista == NULL) { // caso lista vacia
        struct node *nuevo_nodo = (struct node *)malloc(sizeof(struct node));
        strcpy(nuevo_nodo->nombre, nombre);
        nuevo_nodo->danger = danger;
        nuevo_nodo->attack = attack;
        nuevo_nodo->next = NULL;
        *ref_lista = nuevo_nodo;  // aca es donde modificamos la variable lista
    }
    else { // caso lista no vacia
        struct node *lista = *ref_lista;
        struct node *it = lista;
        while(it->next != NULL) { // importante preguntar it->next != NULL y no it != NULL
            it = it->next;
        }
        struct node *nuevo_nodo = (struct node *)malloc(sizeof(struct node));
        strcpy(nuevo_nodo->nombre,nombre);
        nuevo_nodo->danger = danger;
        nuevo_nodo->attack = attack;
        nuevo_nodo->next = NULL;
        it->next = nuevo_nodo;
    }
}
void swap(struct node *nodo1, struct node *nodo2)
{
    char tmp_name[80];
    strcpy(tmp_name, nodo1->nombre);
    float tmp_attack = nodo1->attack;
    strcpy(nodo1->nombre,nodo2->nombre);
    nodo1->attack = nodo2->attack;
    strcpy(nodo2->nombre, tmp_name);
    nodo2->attack = tmp_attack;

}

// ordena los datos de la lista (usa bubble sort)
void ordenar_lista(struct node *lista)
{
    if (lista == NULL){ // caso lista vacia
        return;
    }

    int swapped = 1; // indica si hubo algun swap
    struct node *it = lista;
    while(swapped == 1){
      
        swapped = 0;
        while (it->next != NULL){
         if(it -> attack < it-> next -> attack){
           swap(it, it -> next);
           swapped = 1;
         
            }
            it = it->next;
        }
        it = lista; // inicializamos el iterador it
    }
}




void imprimir_lista(struct node *lista)
{
    // recorrido simple de la lista
    struct node *it = lista;
    while(it != NULL) {
        printf("||%s   |    %f  ||   ", it->nombre, it->attack);
        it = it->next;
    }
    printf("\n");
}

void bubbleSort(struct node *start)
{
    int swapped, i;
    struct node *ptr1;
    struct node *lptr = NULL;

    // Checking for empty list /
    if (start == NULL)
        return;

    do
    {
        swapped = 0;
        ptr1 = start;

        while (ptr1->next != lptr)
        {
            if (ptr1->attack > ptr1->next->attack)
            {
                swap(ptr1, ptr1->next);
                swapped = 1;
            }
            ptr1 = ptr1->next;
        }
        lptr = ptr1;
    }
    while (swapped);
}

void bubbleSort_2(struct node *start)
{
    int swapped, i;
    struct node *ptr1;
    struct nodel *lptr = NULL;

    /* Checking for empty list */
    if (start == NULL)
        return;

    do
    {
        swapped = 0;
        ptr1 = start;

        while (ptr1->next != lptr)
        {
            if (ptr1->attack==-1){
                ptr1 = ptr1->next;
                continue;
            }
            else if(ptr1->attack < ptr1->next->attack)
            {
                swap(ptr1, ptr1->next);
                swapped = 1;
            }
            ptr1 = ptr1->next;
        }
        lptr = ptr1;
    }
    while (swapped);
}

//la función de ordenar alfabéticamente se debe llamar una vez que se tengan las listas ordenadas por probabilidad de ataque

void ordenar_alfabeticamente (struct node *lista){

for (int i = 0; i <10 ; i++){
//falta un while o for para hacerlo en toda la lista
 struct node* it = lista; 


 while (it -> next != NULL)  {
 if (it -> attack == it -> next -> attack) {

    if(strcmp(it -> nombre, it -> next -> nombre) > 0){   
           
            swap (it , it -> next);
      
 }
   } 
   it = it -> next;
}

  }
}

int getCount(struct node* head)
{
    int count = 0;  // Initialize count
    struct node* current = head;  // Initialize current
    while (current != NULL)
    {
        count++;
        current = current->next;
    }
    return count;
}

int main(int argc, char *argv[]) {
    int i = 0;
    FILE *fp = fopen(argv[1], "r");
    char line[MAX_LINE_SIZE];
    char *token;
    struct node *lista_5= NULL;
    struct node *lista_4 = NULL;
    struct node *lista_3 = NULL;
    struct node *lista_2 = NULL;
    struct node *lista_1 = NULL;

    // Leemos linea a linea
    while (fgets(line, MAX_LINE_SIZE, fp) != NULL) // el arreglo line se rellena con los caracteres de la linea
    {
        // strtok(line, ",") entrega el substring desde el comienzo hasta la primera aparicion del delimitador "," (excluyendolo)
        // Copiamos el substring al campo palabra de la estructura

        char nombre[50];
        int danger;
        float attack;


        strcpy(nombre, strtok(line, ","));
        // Obtenemos el siguiente substring
        token = strtok(NULL, ",");
        if (strcmp(token, "\n") == 0) // caso que no hay int
            danger = -1;
        else
            danger = atoi(token); // atoi convierte un string a int
        token = strtok(NULL, ",");
        if (strcmp(token, "\n") == 0) // caso que no hay int
            attack = -1;
        else {
            attack = atof(token); // atoi convierte un string a int
        }


        //hash
        switch (danger) {
            case 1:
                insertar_elemento(&lista_1, nombre, danger, attack);
                break;
            case 2:
                insertar_elemento(&lista_2, nombre, danger, attack);
                break;
            case 3:
                insertar_elemento(&lista_3, nombre, danger, attack);
                break;
            case 4:
                insertar_elemento(&lista_4, nombre, danger, attack);
                break;
            case 5:
                insertar_elemento(&lista_5, nombre, danger, attack);
                break;
        }
        i++;
    }

  

//Creación de una nueva lista para danger 3
    struct node *nueva_lista_3 = NULL;

    int contador = 0;

    //Se crean listas auxiliares
    struct node *ptr1 = lista_3;
    //Se separa en negativos y no negativos
    struct node *negativos = NULL;
    struct node *no_negativos = NULL;

    //Se ordena la lista;
    bubbleSort(lista_3);
    bubbleSort_2(lista_3);

    //Extracción de datos...
    while(ptr1!= NULL){

        if(ptr1->attack!=-1){
            insertar_elemento(&no_negativos, ptr1->nombre, ptr1->danger, ptr1->attack);
        }
        else{
            insertar_elemento(&negativos, ptr1->nombre, ptr1->danger, ptr1->attack);
        }
        contador++;
        ptr1 = ptr1->next;
    }


    //Se obtiene el largo de las listas auxiliares...
    int contador_negativo = getCount(negativos);
    int contador_no_negativo = getCount(no_negativos);


    //Se añaden los datos de las listas auxiliares a la nueva lista 3
    int x = 0;
    while(x<contador){

        if (x<contador_no_negativo/2 || contador_no_negativo< x){

            insertar_elemento(&nueva_lista_3, no_negativos->nombre, no_negativos->danger, no_negativos->attack); //Los datos no negativos se separan para que el centro queden los negativos
            no_negativos = no_negativos->next;
            x++;
        }
        else{
            insertar_elemento(&nueva_lista_3, negativos->nombre, negativos->danger,negativos->attack);
            negativos = negativos->next;
            x++;
        }

    }

    bubbleSort(lista_5);
    bubbleSort(lista_4);
    bubbleSort_2(lista_5);
    bubbleSort_2(lista_4);

  ordenar_lista(lista_1);
  ordenar_lista(lista_2);

  ordenar_alfabeticamente(lista_1);
  ordenar_alfabeticamente(lista_2);
  ordenar_alfabeticamente(nueva_lista_3);
  ordenar_alfabeticamente(lista_4);
  ordenar_alfabeticamente(lista_5);
    //Se imprime las listas...



  
    hash(lista_5, lista_4, nueva_lista_3, lista_2, lista_1, imprimir_lista);
}
